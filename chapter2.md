---
title: Repositories
description: 'This chapter digs a little deeper into how Git stores information and how you can explore a repository''s history.'
---

## How does Git store information?

```yaml
type: PureMultipleChoiceExercise
key: 6d7237913f
lang: bash
xp: 50
```

In order to make common operations fast and minimize storage space,
Git uses a multi-level structure to store data.
In simplified form,
this has three key parts:

1. Every unique version of every file.
   (Git calls these **[blobs](http://datacamp.github.io/glossary/#blob)** because they can contain data of any kind.)
2. **[tree](http://datacamp.github.io/glossary/#tree)** that tracks the names and locations of a set of files.
3. A **[commit](http://datacamp.github.io/glossary/#commit)** that records the author, log message, and other properties
   of a particular commit.

<img src="https://s3.amazonaws.com/assets.datacamp.com/production/course_5355/datasets/commit-tree-blob.png" alt="Commit-Tree-Blob Structure" />

As the diagram shows,
each blob is stored only once,
and blobs are (frequently) shared between trees.
While it may seem redundant to have both trees and commits,
a later part of this lesson will show why the two have to be distinct.

<hr>

Looking at the diagram,
which files changed in the last (bottom-most) commit to this repository?

`@hint`
Look in the right-most column to see which file is new.

`@possible_answers`
- [`data/northern.csv`]
- `report.md`
- `draft.md`

`@feedback`
- Correct!
- No: that is part of the most recent commit, but wasn't changed in it.
- No: that file is no longer present in the tree.

<!-- -------------------------------------------------------------------------------- -->

---

## What is a hash?

```yaml
type: MultipleChoiceExercise
key: 67430280df
lang: bash
xp: 50
```

Every commit to a repository has a unique identifier called a **[hash](http://datacamp.github.io/glossary/#hash)**
(since it is generated by running the changes through a pseudo-random number generator
called a **[hash function](http://datacamp.github.io/glossary/#hash-function)**).
This hash is normally written as a 40-character hexadecimal string
like `7c35a3ce607a14953f070f0f83b5d74c2296ef93`,
but most of the time,
you only have to give Git the first 6 or 8 characters
in order to identify the commit you mean.

Hashes are what enable Git to share data efficiently between repositories.
If two files are the same,
their hashes are guaranteed to be the same.
Similarly,
if two commits contain the same files and have the same ancestors,
their hashes will be the same as well.
Git can therefore tell what information needs to be saved where
by comparing hashes
rather than comparing entire files.

<hr>

Use `cd` to go into the `dental` directory and then run `git log`.
What are the first four characters of the hash of the most recent commit?

`@possible_answers`
- bedc
- 2e1b
- 2e95
- None of the above.

`@hint`
Use `git log` and look at the topmost entry.
Remember that you can use 'q' to quit the pager.

`@pre_exercise_code`
```{python}

```

`@sct`
```{python}
err = "No, that is not the most recent hash."
Ex() >> test_mc(4, [err, err, err, "Correct!"])
```

---

## How can I view a specific commit?

```yaml
type: MultipleChoiceExercise
key: d03c5fa3e6
lang: shell
xp: 50
skills: 1
```

To view the details of a specific commit,
you use the command `git show` with the first few characters of the commit's hash.
For example, the command `git show 043070` produces this:

    commit 0430705487381195993bac9c21512ccfb511056d
    Author: Rep Loop <repl@datacamp.com>
    Date:   Wed Sep 20 13:42:26 2017 +0000
    
        Added year to report title.
    
    diff --git a/report.txt b/report.txt
    index e713b17..4c0742a 100644
    --- a/report.txt
    +++ b/report.txt
    @@ -1,4 +1,4 @@
    -# Seasonal Dental Surgeries 2017-18
    +# Seasonal Dental Surgeries (2017) 2017-18
     
     TODO: write executive summary.

The first part is the same as the log entry shown by `git log`.
The second part shows the changes;
as with `git diff`,
lines that the change removed are prefixed with `-`,
while lines that it added are prefixed with `+`.

<hr>

You have been put in the `dental` directory.
(We will now stop reminding you of this...)
Use `git log` to see the hashes of recent commits,
and then `git show` with the first few digits of a hash
to look at the most recent commit.
How many files did it change?

`@possible_answers`
- None.
- 1.
- 2.
- 4.

`@hint`
Use `git show` and the first 6 characters of the hash
and then look at the names of the files that were changed.

`@pre_exercise_code`
```{shell}
repl = connect('bash')
repl.run_command('cd dental')
```

`@sct`
```{python}
e_more = 'No, there have been more changes than that.'
correct = 'Correct!'
e_fewer = 'No, there have been fewer changes than that.'
Ex() >> test_mc(2, [e_more, correct, e_fewer, e_fewer])
```

---

## What is Git's equivalent of a relative path?

```yaml
type: MultipleChoiceExercise
key: 1bc30ab583
lang: shell
xp: 50
skills: 1
```

A hash is like an absolute path:
it identifies a specific commit.
Another way to identify a commit is to use the equivalent of a relative path.
The special label `HEAD`,
which we saw in the previous chapter,
always refers to the most recent commit.
The label `HEAD~1` then refers to the commit before it,
while `HEAD~2` refers to the commit before that,
and so on.

Note that the symbol between `HEAD` and the number is a tilde `~`,
*not* a minus sign `-`,
and that there cannot be spaces before or after the tilde.

<hr>

You are in the `dental` repository.
Using a single Git command,
look at the commit made just before the most recent one.
Which of the following files did it change?

`@possible_answers`
- `report.txt`.
- `data/western.csv`.
- Both of the above.
- Neither of the above.

`@hint`
The commit before the most recent will be `HEAD~1`.

`@pre_exercise_code`
```{shell}
repl = connect('bash')
repl.run_command('cd dental')
```

`@sct`
```{python}
Ex() >> test_mc(2, ['No, the commid `HEAD~1` did not change that file.',
                    'Correct.',
                    'No, the commit `HEAD~1` only changed one file.',
                    'No, the commit `HEAD~1` did change a file.'])
```

---

## How can I see who changed what in a file?

```yaml
type: MultipleChoiceExercise
key: f76c7f5965
lang: shell
xp: 50
skills: 1
```

`git log` displays the overall history of a project or file,
but Git can give even more information:
the command `git annotate file` shows who made the last change to each line of a file and when.
For example,
the first three lines of output from `git annotate report.txt` look something like this:

```
04307054        (  Rep Loop     2017-09-20 13:42:26 +0000       1)# Seasonal Dental Surgeries (2017) 2017-18
5e6f92b6        (  Rep Loop     2017-09-20 13:42:26 +0000       2)
5e6f92b6        (  Rep Loop     2017-09-20 13:42:26 +0000       3)TODO: write executive summary.
```

The first column is the hash of the most recent commit to change that line.
The other columns show who made the change,
the date and time it was made,
the line number,
and the line itself.

<hr>

You are in the `dental` repository.
Use a single command to see the changes to `report.txt`.
How many different sets of changes have been made to this file
(i.e., how many different hashes show up in the first column of the output)?

`@possible_answers`
- 1.
- 2.
- 3.
- 4.

`@hint`
Use `git annotate report.txt` and count the number of distinct commit IDs
in the first column.

`@pre_exercise_code`
```{shell}
repl = connect('bash')
repl.run_command('cd dental')
```

`@sct`
```{python}
e_more = 'No, there have been more changes than that.'
correct = 'Correct!'
e_fewer = 'No, there have been fewer changes than that.'
Ex() >> test_mc(3, [e_more, e_more, correct, e_fewer])
```

---

## How can I see what changed between two commits?

```yaml
type: MultipleChoiceExercise
key: 9862ae22bd
lang: shell
xp: 50
skills: 1
```

`git show` with a commit ID shows the changes made *in* a particular commit.
To see the changes *between* two commits,
you can use `git diff ID1..ID2`,
where `ID1` and `ID2` identify the two commits you're interested in,
and the connector `..` is a pair of dots.
For example,
`git diff abc123..def456` shows the differences between the commits `abc123` and `def456`,
while `git diff HEAD~1..HEAD~3` shows the differences between the state of the repository one commit in the past
and its state three commits in the past.

<hr>

You are in the `dental` repository.
Use `git diff` to view the differences between its current state
and its state two commits previously.
Which of the following files have changed?

`@possible_answers`
- `data/western.csv`.
- `report.txt`.
- `data/southern.csv`.
- `report.txt` and `data/western.csv`.
- `report.txt` and `data/southern.csv`.

`@hint`
Use `git log` with two `HEAD`-based commit identifiers and look for filenames.

`@pre_exercise_code`
```{shell}
repl = connect('bash')
repl.run_command('cd dental')
```

`@sct`
```{python}
err_more = 'Yes, but another file was changed as well.'
err_not = 'No, that file did not change.'
correct = 'Correct!'
err_half = 'No, one of those files did not change.'
Ex() >> test_mc(4, [err_more, err_more, err_not, correct, err_half])
```

---

## How do I add new files?

```yaml
type: BulletConsoleExercise
key: b91e72ac0c
xp: 100
```

Git does not track files by default.
Instead,
it waits until you have used `git add` at least once
before it starts paying attention to a file.
To remind you to do this,
`git status` will always tell you about files that are in your repository
but aren't (yet) being tracked.

`@pre_exercise_code`
```{python}
with open('dental/sources.txt', 'w') as writer:
    writer.write('Dental data: Euphoric State University Hospital\n')
repl = connect('bash')
repl.run_command('cd dental')
```

***

```yaml
type: ConsoleExercise
key: 0cad38fb5f
xp: 35
```

`@instructions`
You are in the `dental` repository.
Use `git status` to find the files that aren't yet being tracked.

`@hint`
Run the command as indicated.

`@solution`
```{shell}
git status

```

`@sct`
```{python}
Ex() >> test_student_typed(r'\s*git\s+status\s*',
                           fixed=False,
                           msg='Remember, you want to check the *status* of the repository.')

```

***

```yaml
type: ConsoleExercise
key: 7b84819b84
xp: 35
```

`@instructions`
Use `git add` to add the new file to the staging area.

`@hint`
Remember: `git add` shouldb e followed by either a filename or a directory name (such as '.' for the current working directory).

`@solution`
```{shell}
git add sources.txt

```

`@sct`
```{python}
Ex() >> test_student_typed(r'\s*git\s+add\s+(\.|sources\.txt)\s*',
                           fixed=False,
                           msg='You can add files one by one or use a directory to add them all.')

```

***

```yaml
type: ConsoleExercise
key: 4545c769de
xp: 30
```

`@instructions`
Use `git commit` to save the staged files
with the message "Starting to track data sources."

`@hint`
Use `-m "message"` to provide a message to `git commit`.

`@solution`
```{shell}
git commit -m "Starting to track data sources."

```

`@sct`
```{python}
Ex() >> test_student_typed(r'\s*git\s+commit\s+-m\s+"[^"]+"\s*',
                           fixed=False,
                           msg='Remember, you want to *commit* files.')

```

---

## How do I tell Git to ignore certain files?

```yaml
type: PureMultipleChoiceExercise
key: d10c46c6d0
lang: bash
xp: 50
```

Data analysis often produces temporary or intermediate files that you don't want to save.
You can tell it to stop paying attention to files you don't care about
by creating a file in the root directory of your repository called `.gitignore`
and storing a list of **[wildcard](http://datacamp.github.io/glossary/#wildcard)** patterns that specify the files you don't want Git to pay attention to.
For example,
if `.gitignore` contains:

```
build
*.mpl
```

then Git will ignore any file or directory called `build` (and, if it's a directory, anything in it),
as well as any file whose name ends in `.mpl`.

<hr>

Which of the following files would *not* be ignored by a `.gitignore` that contained the lines:

```
pdf
*.pyc
backup
```

`@hint`
To match a set of files, a `.gitignore` entry must contain a wildcard character such as `*`.

`@possible_answers`
- [`report.pdf`]
- `bin/analyze.pyc`
- `backup/northern.csv`
- None of the above.

`@feedback`
- Correct: `pdf` does not contain any wildcards, so it only matches files called `pdf`.
- This file *is* matched because the pattern `*.pyc` matches files in sub-directories.
- This file *is* matched because `backup` is a directory, so all files in it are ignored.
- No: at least one of the files above is not ignored.

<!-- -------------------------------------------------------------------------------- -->

---

## How can I remove unwanted files?

```yaml
type: BulletConsoleExercise
key: 3949f5c938
xp: 100
```

Git can help you clean up files that you have told it you don't want.
The command `git clean -n` will show you a list of files that are in the repository,
but whose history Git is not currently tracking.
A similar command `git clean -f` will then delete those files.

*Use this command carefully:*
`git clean` only works on untracked files,
so by definition,
their history has not been saved.
If you delete them with `git clean -f`,
they're gone for good.

`@pre_exercise_code`
```{python}
with open('dental/backup.log', 'w') as writer:
    writer.write('Backing up...\nBackup complete.\n')
repl = connect('bash')
repl.run_command('cd dental')
```

***

```yaml
type: ConsoleExercise
key: e3a590cd63
xp: 35
```

`@instructions`
You are in the `dental` repository.
Use `ls` to see what files are present.

`@hint`
Run the command as shown.

`@solution`
```{shell}
ls

```

`@sct`
```{python}
Ex() >> test_student_typed(r'\s*ls\s*',
                           fixed=False,
                           msg='Use `ls` without arguments.')

```

***

```yaml
type: ConsoleExercise
key: 4bbdbc8970
xp: 35
```

`@instructions`
Use a single Git command to remove unwanted files.

`@hint`
The `-f` flag to `git clean` forces file removal.

`@solution`
```{shell}
git clean -f

```

`@sct`
```{python}
Ex() >> test_student_typed(r'\s*git\s+clean\s+-f\s*',
                           fixed=False,
                           msg='Use `git clean` with the right flag(s).')

```

***

```yaml
type: ConsoleExercise
key: 0450972363
xp: 30
```

`@instructions`
Use `ls` again to see what effects your Git command has had.

`@hint`
Run the command as shown.

`@solution`
```{shell}
ls

```

`@sct`
```{python}
Ex() >> test_student_typed(r'\s*ls\s*',
                           fixed=False,
                           msg='Use `ls` without arguments.')

```

---

## How can I see how Git is configured?

```yaml
type: MultipleChoiceExercise
key: ee41a600fb
lang: shell
xp: 50
skills: 1
```

Like most complex pieces of software,
Git allows you to change its default settings.
To see what the settings are,
you can use the command `git config --list` with one of three additional options:

- `--system`: settings for every user on this computer.
- `--global`: settings for every one of your projects.
- `--local`: settings for one specific project.

Each level overrides the one above it,
so **[local settings](http://datacamp.github.io/glossary/#local-settings)** (per-project)
take precedence over **[global settings](http://datacamp.github.io/glossary/#global-settings)** (per-user),
which in turn take precedence over **[system settings](http://datacamp.github.io/glossary/#system-settings)** (for all users on the computer).

<hr>

You are in the `dental` repository.
How many local configuration values are set in for this repository?

`@possible_answers`
- None.
- 1.
- 4.
- 12.

`@hint`
Use `git config --list --local` and count.

`@pre_exercise_code`
```{shell}
repl = connect('bash')
repl.run_command('cd dental')
```

`@sct`
```{python}
Ex() >> test_mc(3, ['No, some configuration values are set.',
                    'No, more configuration values are set than that.',
                    'Correct!',
                    'No, fewer configuration values are set than that.'])
```

---

## How can I change my Git configuration?

```yaml
type: ConsoleExercise
key: 7c0dce348b
lang: shell
skills: 1
```

Most of Git's settings should be left as they are.
However,
there are two you should set on every computer you use:
your name and your email address.
These are recorded in the log every time you commit a change,
and are often used to identify the authors of a project's content in order to give credit
(or assign blame, depending on the circumstances).

To change a configuration value for all of your projects on a particular computer,
run the command:

```
git config --global setting.name setting.value
```

with the setting's name and value in the appropriate places.
The keys that identify your name and email address are `user.name` and `user.email` respectively.

`@instructions`
Change the email address configured for the current user for *all* projects
to `rep.loop@datacamp.com`.

`@hint`


`@pre_exercise_code`
```{python}

```

`@solution`
```{shell}
git config --global user.email rep.loop@datacamp.com
```

`@sct`
```{python}
Ex() >> test_student_typed(r'\s*git\s+config\s+--global\s+user\.email\s+["\']?rep\.loop@datacamp.com["\']?\s*',
                           fixed=False,
                           msg='Use `git config --global` with the `user.email` property and the email address.')
```
